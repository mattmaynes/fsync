#!/bin/bash

NAME='fsync'
AUTHOR='Matthew Maynes'
VERSION='0.0.2'
HELP='
Usage: fsync [OPTIONS ...] SOURCE DESTINATION\n
\n
  Synchronizes the source directory with the destination directory.\n
  The directories will be synced initially and then a monitor will be\n
  attached to SOURCE to track any changes made.\n
\n
  Options:\n
\n
\t  -c, --checksum\t\t  Use checksum comparisons instead of time stamps\n
\t\t\t\t                This takes slightly more resources to compute but\n
\t\t\t\t                is more accurate than times, especially when dealing\n
\t\t\t\t                with remote servers.\n
\n
\t  --progress\t\t      Display progress while synchronizing files\n
\n
\t  -h, --help\t\t      Display this message and exit\n
\n
\t  --version\t\t       Display the version of this script and exit\n
\n
'

#####################
#     VARIABLES     #
#####################

# The source directory to watch for changes and 
# keep in sync with the destination.
#
# @type {string}
SOURCE=''

# The destination directory to keep synchronized with
# the source
#
# @type {string}
DEST=''

# A list of special arguments for rsync
#
# @type {string}
RSYNC='--recursive --relative'

# The paths that have been input. This is used when 
# parsing the command line arguments. It holds a copy
# of the input and destination locations
#
# @type {array}
PATHS=()

#####################
#     FUNCTIONS     #
#####################

function info {
    echo -e " $NAME $VERSION\n$HELP"
}

# Watches a given directory using fswatch for a file 
# change. When there is a change it synchronizes
# a destination directory.
#
# @param {string} Any arguments for rsync
# @param {string} The source directory to watch
# @param {string} The destination to keep synchronized
function watch {
    # While there are more changes synchronize them with
    # the destination location
    while read -d "" file;
    do
        # fswatch sometimes shows index files that have
        # changed but they don't actually exist. Ensure
        # that each changed file actually exists
        if [ -e $file  ];
        then
            # All paths need to be relative to the 
            # SOURCE directory. To do that we need to add
            # /. to the path so rsync knows where the base is
            change=$(sed "s/$1/$1\/./g" <<< $file);

            # Report the change
            echo "Change detected in $file";
            
            # Synchronize the files by using rsync
            rsync $RSYNC $change $2
        fi
    # fswatch behaves as a notification stream that will
    # trigger the while loop for each change. The < <()
    # syntax allows the output of fswatch to be piped 
    # into the input of the while loop
    done < <(fswatch -0 -r -e .git/ -e *.swp $1)
}


####################
#    PARSE ARGS    #
####################
IFS=' ' read -ra ARGV <<< $@

# Iterate over each argument in the input vector
for i in "${ARGV[@]}"; do
    case $i in
        '-h' | '--help' )
            info;
            exit 0;;
        '--version' )
            echo -e "$NAME $VERSION";
            exit 0;;
        '-c' |  '--checksum' | '--progress' )
            RSYNC="$RSYNC $i";;
        
        # Default case for all flags
        -* )
            echo 'Unknown argument ' $i;
            exit 1;;
        
        # Catch data and throw it in the PATHS array
        *)
            PATHS+=("$i");;
    esac
done

# There must be at least 2 PATHS to continue. One for the
# input and one for the output. 
if [ ${#PATHS[@]} -lt 2 ]; then
    echo 'Missing input path';
    echo 'See fysnc --help for usage';
    exit 1;
fi

# Get a reference to the source and destination locations
SOURCE=${PATHS[0]};
DEST=${PATHS[1]};


# Perform an initial synchronization of the source location.
echo "Performing initial synchronization of $SOURCE to $DEST"
rsync $RSYNC $SOURCE $DEST
echo "Synchronization complete"

# Watch the source location for changes and sync the 
# destination when there is one
echo "Watching $SOURCE for changes"
watch $SOURCE $DEST



